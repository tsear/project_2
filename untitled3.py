# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xH2LfbW9qim7mGyHD7cIyhFHlsTT5334
"""

!pip install yfinance pandas-ta vectorbt plotly --quiet

import numpy as np
import pandas as pd
import pandas_ta as ta

from sklearn.decomposition import PCA
import vectorbt as vbt

def columns_to_lower_snake_case(df):
  df.columns = [column.lower().replace(" ", "_") for column in df.columns]

# create a dictionary of stock tickers
tickers = {"adbe": pd.DataFrame(), 
           "sq": pd.DataFrame(), 
           "twtr": pd.DataFrame(),
           "aapl": pd.DataFrame(),
           "amzn": pd.DataFrame(),
           "msft": pd.DataFrame(),
           "tsla": pd.DataFrame(),
           "googl": pd.DataFrame(),
           "ipi": pd.DataFrame(),
           "bg": pd.DataFrame(),
           "tsn": pd.DataFrame(),
           "cf": pd.DataFrame(),
           "ntr": pd.DataFrame(),
           }

# save each stock dataframe to a dictionary
for key, value in tickers.items():
  tickers[key] = pd.DataFrame().ta.ticker(key)
  columns_to_lower_snake_case(tickers[key])

for stock in tickers.values():
  display(stock)

# create strategies to test
strategies = {
    "bbands": ta.Strategy(
      name="bollinger bands, SMA 50/200, EMA",
      ta=[
        {"kind": "sma", "length": 50},
        {"kind": "sma", "length": 200},
        {"kind": "bbands", "length": 20},
        {"kind": "ema", "length": 10},
        {"kind":"linreg", "close": "bbb_20_2.0", "length": 8, "prefix": "bbb_20_2.0"}
        ]
      ),

    "rsi": ta.Strategy(
      name="RSI",
      ta=[
        {"kind": "rsi", "length": 50},
        {"kind": "rsi", "length": 200}
          ]
      ),
    # Keltner Channel
    "kc": ta.Strategy(
        name='Keltner Channel',
        ta=[
          {"kind": "kc", "length": 50},
          {"kind": "kc", "length": 200}
          ]
    )

}

# run each strategy on each stock
for strat in strategies.values():
  for stock in tickers.values():
    # columns_to_lower_snake_case(stock)
    stock.ta.strategy(strat)
    stock.dropna(inplace=True)
    columns_to_lower_snake_case(stock)

# generate a golden cross signal for each stock
for stock in tickers.values():
  stock['golden_cross'] = 0.0
  stock.loc[(stock['sma_50'] > stock['sma_200']), 'golden_cross'] = 0
  stock.loc[(stock['sma_50'] < stock['sma_200']), 'golden_cross'] = 1
  stock.ta.tsignals(stock["golden_cross"], asbool=False, append=True, prefix="sma")
  columns_to_lower_snake_case(stock)

  # Strategy 2
  stock['rsi'] = 0.0
  stock.loc[(stock['rsi_50'] > stock['rsi_200']), 'rsi'] = 0
  stock.loc[(stock['rsi_50'] < stock['rsi_200']), 'rsi'] = 1
  stock.ta.tsignals(stock["rsi"], asbool=False, append=True, prefix="rsi")
  columns_to_lower_snake_case(stock)

  #Strategy 3
  stock['kc'] = 0.0
  stock.loc[(stock['kcbe_50_2'] > stock['kcue_200_2']), 'kc'] = 0
  stock.loc[(stock['kcbe_50_2'] < stock['kcue_200_2']), 'kc'] = 1
  stock.ta.tsignals(stock["kc"], asbool=False, append=True, prefix="kc")
  columns_to_lower_snake_case(stock)

# get all entry points
tickers["adbe"].loc[tickers["adbe"]["rsi_ts_entries"] == True]

tickers["adbe"].loc[tickers["adbe"].index >"2000"]

strategy_1_risk_df = pd.DataFrame()
strategy_2_risk_df = pd.DataFrame()
strategy_3_risk_df = pd.DataFrame()

for ticker, stock in tickers.items():
  portfolio_1 = vbt.Portfolio.from_signals(stock["close"], 
                                  entries=stock["sma_ts_entries"], 
                                  exits=stock["sma_ts_exits"], 
                                  freq="D", 
                                  init_cash=100_000, 
                                  fees=0.0025, 
                                  slippage=0.0025)
    
  portfolio_2 = vbt.Portfolio.from_signals(stock["close"], 
                                  entries=stock["rsi_ts_entries"], 
                                  exits=stock["rsi_ts_exits"], 
                                  freq="D", 
                                  init_cash=100_000, 
                                  fees=0.0025, 
                                  slippage=0.0025)
  
  portfolio_3 = vbt.Portfolio.from_signals(stock["close"], 
                                  entries=stock["rsi_ts_entries"], 
                                  exits=stock["rsi_ts_exits"], 
                                  freq="D", 
                                  init_cash=100_000, 
                                  fees=0.0025, 
                                  slippage=0.0025)
  
  # the higher the number the more days the drawdown lasted
  drawdown_tolerance = portfolio_1.returns_stats()["Period"]/portfolio_1.returns_stats()["Max Drawdown Duration"]
  value_at_risk = portfolio_1.returns_stats()["Value at Risk"]
  max_drawdown = portfolio_1.returns_stats()["Max Drawdown [%]"]/100
  df_1 = pd.DataFrame({
      "drawdown_tolerance": drawdown_tolerance,
      "value_at_risk": value_at_risk,
      "max_drawdown": max_drawdown,
      "risk_score": ((drawdown_tolerance + value_at_risk + max_drawdown) /3)
  }, index=[ticker])
  strategy_1_risk_df = pd.concat([strategy_1_risk_df, df_1])


  drawdown_tolerance = portfolio_2.returns_stats()["Period"]/portfolio_2.returns_stats()["Max Drawdown Duration"]
  value_at_risk = portfolio_2.returns_stats()["Value at Risk"]
  max_drawdown = portfolio_2.returns_stats()["Max Drawdown [%]"]/100
  df_2 = pd.DataFrame({
      "drawdown_tolerance": drawdown_tolerance,
      "value_at_risk": value_at_risk,
      "max_drawdown": max_drawdown
  }, index=[ticker])
  strategy_2_risk_df = pd.concat([strategy_2_risk_df, df_2])
  
  drawdown_tolerance = portfolio_3.returns_stats()["Period"]/portfolio_3.returns_stats()["Max Drawdown Duration"]
  value_at_risk = portfolio_3.returns_stats()["Value at Risk"]
  max_drawdown = portfolio_3.returns_stats()["Max Drawdown [%]"]/100
  df_3 = pd.DataFrame({
      "drawdown_tolerance": drawdown_tolerance,
      "value_at_risk": value_at_risk,
      "max_drawdown": max_drawdown
  }, index=[ticker])
  strategy_3_risk_df = pd.concat([strategy_3_risk_df, df_3])


  print(f"\n{'*' * 50}")
  print(ticker.upper())
  print(f"{'*' * 50}\n")
  print(f"{'*' * 50}")
  print('Portfolio Stats')
  print(f"{'*' * 50}\n")
  display(portfolio_3.stats())
  print(f"\n{'*' * 50}")
  print('Return Stats')
  print(f"{'*' * 50}\n")
  display(portfolio_3.returns_stats())

strategy_2_risk_df

tickers["adbe"].vbt.plot().show()

from IPython.display import HTML
import plotly.graph_objects as go
from plotly.subplots import make_subplots

def make_plots(ticker, stock, indicator_1, indicator_2, entry_marker, exit_marker):
  fig = go.Figure(go.Candlestick(x=stock.index,
                                 open=stock['open'],
                                 high=stock['high'],
                                 low=stock['low'],
                                 close=stock['close']
                                 ))
  fig.update_xaxes(rangebreaks=[dict(bounds=["sat", "mon"])])
  dt_all = pd.date_range(start=stock.index[0],end=stock.index[-1])
  dt_obs = [d.strftime("%Y-%m-%d") for d in pd.to_datetime(stock.index)]
  dt_breaks = [d for d in dt_all.strftime("%Y-%m-%d").tolist() if not d in dt_obs]
  fig.update_xaxes(rangebreaks=[dict(values=dt_breaks)])

  fig.add_trace(go.Scatter(x=stock.index, 
                         y=stock[indicator_1], 
                         opacity=0.7, 
                         line=dict(color='blue', width=2), 
                         name=indicator_1))
  fig.add_trace(go.Scatter(x=stock.index, 
                         y=stock[indicator_2], 
                         opacity=0.7, 
                         line=dict(color='orange', width=2), 
                         name=indicator_2))
  
  
  fig.add_trace(go.Scatter(mode='markers',
        x=stock.loc[stock[entry_marker] == 1].index,
        y=stock['close'].loc[stock[entry_marker] == 1],
        marker_symbol="triangle-up",
        marker_line_color="green", 
        marker_color="green",
        marker_line_width=2, 
        marker_size=15,
        showlegend=False
        ))
  
  fig.add_trace(go.Scatter(mode='markers',
        x=stock.loc[stock[exit_marker] == 1].index,
        y=stock['close'].loc[stock[exit_marker] == 1],
        marker_symbol="triangle-down",
        marker_line_color="red", 
        marker_color="red",
        marker_line_width=2, 
        marker_size=15,
        showlegend=False
        ))

  fig.update_xaxes(rangebreaks=[dict(values=dt_breaks)])
  fig.update_layout(title=ticker.upper())
  fig.update_layout(autosize=False,
                    width=800,
                    height=800)
  return fig

for ticker, stock in tickers.items():
  fig_1 = make_plots(ticker, stock, "sma_50", "sma_200", "sma_ts_entries", "sma_ts_exits")

  fig_2 = make_plots(ticker, stock, "rsi_50", "rsi_200", "rsi_ts_entries", "rsi_ts_exits")

  fig_3 = make_plots(ticker, stock, "kcbe_50_2", "kcue_200_2", "kc_ts_entries", "kc_ts_exits")
  # write the figure streamlit
  # st.write(fig) or st.write(fig.to_html())
  display(HTML(fig_2.to_html()))

